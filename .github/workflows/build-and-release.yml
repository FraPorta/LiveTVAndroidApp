name: Build and Release Android APK

on:
 # Trigger on push to main/master branch
 push:
  branches: [ master, main ]
  paths-ignore:
   - '**.md'
   - '.gitignore'
   - 'LICENSE'

 # Trigger on pull request to main/master
 pull_request:
  branches: [ master, main ]

 # Allow manual trigger
 workflow_dispatch:
  inputs:
   release_type:
    description: 'Release type'
    required: true
    default: 'debug'
    type: choice
    options:
     - debug
     - release

jobs:
 build:
  runs-on: ubuntu-latest
  permissions:
   contents: write
   actions: read

  steps:
   - name: Checkout repository
     uses: actions/checkout@v4
     with:
      token: ${{ secrets.GITHUB_TOKEN }}
      fetch-depth: 0

   - name: Set up JDK 17
     uses: actions/setup-java@v4
     with:
      java-version: '17'
      distribution: 'temurin'

   - name: Cache Gradle dependencies
     uses: actions/cache@v4
     with:
      path: |
       ~/.gradle/caches
       ~/.gradle/wrapper
      key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
      restore-keys: |
       ${{ runner.os }}-gradle-

   - name: Make gradlew executable
     run: chmod +x gradlew

   - name: Clean project
     run: ./gradlew clean

   - name: Set up release keystore
     if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type == 'release')
     run: |
      # Create keystore directory
      mkdir -p app/keystore
      
      # Decode and save the keystore file
      echo "${{ secrets.KEYSTORE_B64 }}" | base64 -d > app/keystore/release.jks
      
      # Verify keystore was decoded correctly
      ls -la app/keystore/release.jks
      echo "Keystore file size: $(wc -c < app/keystore/release.jks) bytes"
      
      # Test keystore accessibility (without showing passwords)
      echo "Testing keystore format..."
      if keytool -list -keystore app/keystore/release.jks -storepass "${{ secrets.RELEASE_STORE_PASSWORD }}" -alias "${{ secrets.RELEASE_KEY_ALIAS }}" > /dev/null 2>&1; then
        echo "✅ Keystore is accessible and valid"
      else
        echo "❌ Keystore test failed"
        exit 1
      fi
      
      # Set up gradle properties for release signing
      echo "RELEASE_STORE_FILE=app/keystore/release.jks" >> gradle.properties
      echo "RELEASE_STORE_PASSWORD=${{ secrets.RELEASE_STORE_PASSWORD }}" >> gradle.properties
      echo "RELEASE_KEY_ALIAS=${{ secrets.RELEASE_KEY_ALIAS }}" >> gradle.properties
      echo "RELEASE_KEY_PASSWORD=${{ secrets.RELEASE_KEY_PASSWORD }}" >> gradle.properties   - name: Auto-increment version
     if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
     run: |
      # Extract current version
      CURRENT_VERSION_NAME=$(grep -E "versionName\s*=" app/build.gradle.kts | sed -E 's/.*versionName\s*=\s*"([^"]+)".*/\1/')
      CURRENT_VERSION_CODE=$(grep -E "versionCode\s*=" app/build.gradle.kts | sed -E 's/.*versionCode\s*=\s*([0-9]+).*/\1/')

      # Increment patch version (assumes semver format like 1.0.2)
      IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION_NAME"
      MAJOR=${VERSION_PARTS[0]}
      MINOR=${VERSION_PARTS[1]}
      PATCH=${VERSION_PARTS[2]}

      # Increment patch version
      NEW_PATCH=$((PATCH + 1))
      NEW_VERSION_NAME="$MAJOR.$MINOR.$NEW_PATCH"
      NEW_VERSION_CODE=$((CURRENT_VERSION_CODE + 1))

      echo "Current version: $CURRENT_VERSION_NAME (code: $CURRENT_VERSION_CODE)"
      echo "New version: $NEW_VERSION_NAME (code: $NEW_VERSION_CODE)"

      # Update build.gradle.kts with new version
      sed -i "s/versionCode = $CURRENT_VERSION_CODE/versionCode = $NEW_VERSION_CODE/" app/build.gradle.kts
      sed -i "s/versionName = \"$CURRENT_VERSION_NAME\"/versionName = \"$NEW_VERSION_NAME\"/" app/build.gradle.kts

      echo "Version updated in build.gradle.kts for build process"

   - name: Build debug APK
     if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type == 'debug') || github.event_name == 'push'
     run: ./gradlew assembleDebug

   - name: Build release APK
     if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_type == 'release')
     run: ./gradlew assembleRelease

   - name: Commit version update
     if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main')
     run: |
      # Commit the version update back to the repository
      git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
      git config --local user.name "github-actions[bot]"

      # Get the updated version for commit message
      NEW_VERSION_NAME=$(grep -E "versionName\s*=" app/build.gradle.kts | sed -E 's/.*versionName\s*=\s*"([^"]+)".*/\1/')

      # Check if there are changes to commit
      if git diff --quiet app/build.gradle.kts; then
        echo "No version changes to commit"
      else
        echo "Committing version update..."
        git add app/build.gradle.kts
        git commit -m "🚀 Auto-increment version to $NEW_VERSION_NAME [skip ci]"
        
        # Push the commit back to the repository
        BRANCH_NAME=${GITHUB_REF#refs/heads/}
        git push origin HEAD:$BRANCH_NAME
        echo "Version update committed and pushed successfully to $BRANCH_NAME"
      fi

   - name: Get version info
     id: version
     run: |
      # Extract version from build.gradle.kts (now potentially updated)
      VERSION_NAME=$(grep -E "versionName\s*=" app/build.gradle.kts | sed -E 's/.*versionName\s*=\s*"([^"]+)".*/\1/')
      VERSION_CODE=$(grep -E "versionCode\s*=" app/build.gradle.kts | sed -E 's/.*versionCode\s*=\s*([0-9]+).*/\1/')
      COMMIT_HASH=$(git rev-parse --short HEAD)
      COMMIT_MSG=$(git log -1 --pretty=%B | head -1)

      # Create a clean tag name for releases
      TAG_NAME="v$VERSION_NAME"

      # Determine if we should create a release (only on push to master)
      SHOULD_RELEASE="false"
      if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/master" ]; then
        SHOULD_RELEASE="true"
      fi

      echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
      echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
      echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
      echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT
      echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
      echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

   - name: Rename APK files
     run: |
      # Create output directory
      mkdir -p output

      # Copy and rename APK files with clean version names
      if [ -f app/build/outputs/apk/debug/app-debug.apk ]; then
        cp app/build/outputs/apk/debug/app-debug.apk output/LiveTV-${{ steps.version.outputs.tag_name }}-debug.apk
      fi

      if [ -f app/build/outputs/apk/release/app-release-unsigned.apk ]; then
        cp app/build/outputs/apk/release/app-release-unsigned.apk output/LiveTV-${{ steps.version.outputs.tag_name }}-release-unsigned.apk
      fi

      if [ -f app/build/outputs/apk/release/app-release.apk ]; then
        cp app/build/outputs/apk/release/app-release.apk output/LiveTV-${{ steps.version.outputs.tag_name }}-release.apk
      fi

      # List files for verification
      ls -la output/

   - name: Upload APK artifacts
     uses: actions/upload-artifact@v4
     with:
      name: LiveTV-APKs-${{ steps.version.outputs.tag_name }}
      path: output/*.apk
      retention-days: 30

   - name: Create or Update Release with APKs
     if: ${{ steps.version.outputs.should_release == 'true' }}
     env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
     run: |
      # Debug: List all files in output directory
      echo "=== Files in output directory ==="
      ls -la output/

      # APKs are already properly named, just verify they exist
      echo "=== Available APK files for release ==="
      ls -la output/*.apk 2>/dev/null || echo "No APK files found!"

      # Verify we have at least one APK to release
      if ! ls output/*.apk 1> /dev/null 2>&1; then
        echo "ERROR: No APK files found to release!"
        exit 1
      fi      # Debug: List final APK files
      echo "=== Final APK files for release ==="
      find output/ -name "*.apk" -type f | sort

      # Create or update the release with GitHub CLI
      gh release create ${{ steps.version.outputs.tag_name }} \
        --title "LiveTV AndroidTV v${{ steps.version.outputs.tag_name }}" \
        --notes "Automated release of LiveTV AndroidTV app v${{ steps.version.outputs.tag_name }}

      ## What's Included
      - **LiveTV-${{ steps.version.outputs.tag_name }}-release.apk** - Production release build  
      - **LiveTV-${{ steps.version.outputs.tag_name }}-debug.apk** - Debug build for testing

      ## Installation
      Download the release APK to your Android TV device and install via ADB or file manager.

      ## Changes
      See commit history for detailed changes since the last release." \
        $(find output/ -name "*.apk" -type f) \
        || (echo "Release already exists, uploading files..." && \
            gh release upload ${{ steps.version.outputs.tag_name }} \
               $(find output/ -name "*.apk" -type f) \
               --clobber)

 notification:
  runs-on: ubuntu-latest
  needs: build
  if: always()

  steps:
   - name: Build Status Notification
     run: |
      if [ "${{ needs.build.result }}" == "success" ]; then
        echo "✅ Build completed successfully!"
        echo "📱 APK files have been built and uploaded"
        if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/master" ]; then
          echo "🚀 New release has been automatically created!"
          echo "🔗 Download: https://github.com/${{ github.repository }}/releases/latest"
          echo "📋 All releases: https://github.com/${{ github.repository }}/releases"
        else
          echo "📦 Build artifacts are available in the Actions section"
        fi
      else
        echo "❌ Build failed!"
        echo "Please check the workflow logs for detailed error information"
        echo "🔧 Common issues: Missing dependencies, syntax errors, or build configuration"
      fi
